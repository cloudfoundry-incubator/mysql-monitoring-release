// Code generated by counterfeiter. DO NOT EDIT.
package metricsfakes

import (
	"mysql-metrics/metrics"
	"sync"
)

type FakeGatherer struct {
	DatabaseMetadataStub        func() (globalStatus map[string]string, globalVariables map[string]string, err error)
	databaseMetadataMutex       sync.RWMutex
	databaseMetadataArgsForCall []struct{}
	databaseMetadataReturns     struct {
		result1 map[string]string
		result2 map[string]string
		result3 error
	}
	databaseMetadataReturnsOnCall map[int]struct {
		result1 map[string]string
		result2 map[string]string
		result3 error
	}
	FollowerMetadataStub        func() (slaveStatus map[string]string, heartbeatStatus map[string]string, err error)
	followerMetadataMutex       sync.RWMutex
	followerMetadataArgsForCall []struct{}
	followerMetadataReturns     struct {
		result1 map[string]string
		result2 map[string]string
		result3 error
	}
	followerMetadataReturnsOnCall map[int]struct {
		result1 map[string]string
		result2 map[string]string
		result3 error
	}
	IsDatabaseFollowerStub        func() (bool, error)
	isDatabaseFollowerMutex       sync.RWMutex
	isDatabaseFollowerArgsForCall []struct{}
	isDatabaseFollowerReturns     struct {
		result1 bool
		result2 error
	}
	isDatabaseFollowerReturnsOnCall map[int]struct {
		result1 bool
		result2 error
	}
	IsDatabaseAvailableStub        func() bool
	isDatabaseAvailableMutex       sync.RWMutex
	isDatabaseAvailableArgsForCall []struct{}
	isDatabaseAvailableReturns     struct {
		result1 bool
	}
	isDatabaseAvailableReturnsOnCall map[int]struct {
		result1 bool
	}
	DiskStatsStub        func() (map[string]string, error)
	diskStatsMutex       sync.RWMutex
	diskStatsArgsForCall []struct{}
	diskStatsReturns     struct {
		result1 map[string]string
		result2 error
	}
	diskStatsReturnsOnCall map[int]struct {
		result1 map[string]string
		result2 error
	}
	BrokerStatsStub        func() (map[string]string, error)
	brokerStatsMutex       sync.RWMutex
	brokerStatsArgsForCall []struct{}
	brokerStatsReturns     struct {
		result1 map[string]string
		result2 error
	}
	brokerStatsReturnsOnCall map[int]struct {
		result1 map[string]string
		result2 error
	}
	CPUStatsStub        func() (map[string]string, error)
	cPUStatsMutex       sync.RWMutex
	cPUStatsArgsForCall []struct{}
	cPUStatsReturns     struct {
		result1 map[string]string
		result2 error
	}
	cPUStatsReturnsOnCall map[int]struct {
		result1 map[string]string
		result2 error
	}
	invocations      map[string][][]interface{}
	invocationsMutex sync.RWMutex
}

func (fake *FakeGatherer) DatabaseMetadata() (globalStatus map[string]string, globalVariables map[string]string, err error) {
	fake.databaseMetadataMutex.Lock()
	ret, specificReturn := fake.databaseMetadataReturnsOnCall[len(fake.databaseMetadataArgsForCall)]
	fake.databaseMetadataArgsForCall = append(fake.databaseMetadataArgsForCall, struct{}{})
	fake.recordInvocation("DatabaseMetadata", []interface{}{})
	fake.databaseMetadataMutex.Unlock()
	if fake.DatabaseMetadataStub != nil {
		return fake.DatabaseMetadataStub()
	}
	if specificReturn {
		return ret.result1, ret.result2, ret.result3
	}
	return fake.databaseMetadataReturns.result1, fake.databaseMetadataReturns.result2, fake.databaseMetadataReturns.result3
}

func (fake *FakeGatherer) DatabaseMetadataCallCount() int {
	fake.databaseMetadataMutex.RLock()
	defer fake.databaseMetadataMutex.RUnlock()
	return len(fake.databaseMetadataArgsForCall)
}

func (fake *FakeGatherer) DatabaseMetadataReturns(result1 map[string]string, result2 map[string]string, result3 error) {
	fake.DatabaseMetadataStub = nil
	fake.databaseMetadataReturns = struct {
		result1 map[string]string
		result2 map[string]string
		result3 error
	}{result1, result2, result3}
}

func (fake *FakeGatherer) DatabaseMetadataReturnsOnCall(i int, result1 map[string]string, result2 map[string]string, result3 error) {
	fake.DatabaseMetadataStub = nil
	if fake.databaseMetadataReturnsOnCall == nil {
		fake.databaseMetadataReturnsOnCall = make(map[int]struct {
			result1 map[string]string
			result2 map[string]string
			result3 error
		})
	}
	fake.databaseMetadataReturnsOnCall[i] = struct {
		result1 map[string]string
		result2 map[string]string
		result3 error
	}{result1, result2, result3}
}

func (fake *FakeGatherer) FollowerMetadata() (slaveStatus map[string]string, heartbeatStatus map[string]string, err error) {
	fake.followerMetadataMutex.Lock()
	ret, specificReturn := fake.followerMetadataReturnsOnCall[len(fake.followerMetadataArgsForCall)]
	fake.followerMetadataArgsForCall = append(fake.followerMetadataArgsForCall, struct{}{})
	fake.recordInvocation("FollowerMetadata", []interface{}{})
	fake.followerMetadataMutex.Unlock()
	if fake.FollowerMetadataStub != nil {
		return fake.FollowerMetadataStub()
	}
	if specificReturn {
		return ret.result1, ret.result2, ret.result3
	}
	return fake.followerMetadataReturns.result1, fake.followerMetadataReturns.result2, fake.followerMetadataReturns.result3
}

func (fake *FakeGatherer) FollowerMetadataCallCount() int {
	fake.followerMetadataMutex.RLock()
	defer fake.followerMetadataMutex.RUnlock()
	return len(fake.followerMetadataArgsForCall)
}

func (fake *FakeGatherer) FollowerMetadataReturns(result1 map[string]string, result2 map[string]string, result3 error) {
	fake.FollowerMetadataStub = nil
	fake.followerMetadataReturns = struct {
		result1 map[string]string
		result2 map[string]string
		result3 error
	}{result1, result2, result3}
}

func (fake *FakeGatherer) FollowerMetadataReturnsOnCall(i int, result1 map[string]string, result2 map[string]string, result3 error) {
	fake.FollowerMetadataStub = nil
	if fake.followerMetadataReturnsOnCall == nil {
		fake.followerMetadataReturnsOnCall = make(map[int]struct {
			result1 map[string]string
			result2 map[string]string
			result3 error
		})
	}
	fake.followerMetadataReturnsOnCall[i] = struct {
		result1 map[string]string
		result2 map[string]string
		result3 error
	}{result1, result2, result3}
}

func (fake *FakeGatherer) IsDatabaseFollower() (bool, error) {
	fake.isDatabaseFollowerMutex.Lock()
	ret, specificReturn := fake.isDatabaseFollowerReturnsOnCall[len(fake.isDatabaseFollowerArgsForCall)]
	fake.isDatabaseFollowerArgsForCall = append(fake.isDatabaseFollowerArgsForCall, struct{}{})
	fake.recordInvocation("IsDatabaseFollower", []interface{}{})
	fake.isDatabaseFollowerMutex.Unlock()
	if fake.IsDatabaseFollowerStub != nil {
		return fake.IsDatabaseFollowerStub()
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fake.isDatabaseFollowerReturns.result1, fake.isDatabaseFollowerReturns.result2
}

func (fake *FakeGatherer) IsDatabaseFollowerCallCount() int {
	fake.isDatabaseFollowerMutex.RLock()
	defer fake.isDatabaseFollowerMutex.RUnlock()
	return len(fake.isDatabaseFollowerArgsForCall)
}

func (fake *FakeGatherer) IsDatabaseFollowerReturns(result1 bool, result2 error) {
	fake.IsDatabaseFollowerStub = nil
	fake.isDatabaseFollowerReturns = struct {
		result1 bool
		result2 error
	}{result1, result2}
}

func (fake *FakeGatherer) IsDatabaseFollowerReturnsOnCall(i int, result1 bool, result2 error) {
	fake.IsDatabaseFollowerStub = nil
	if fake.isDatabaseFollowerReturnsOnCall == nil {
		fake.isDatabaseFollowerReturnsOnCall = make(map[int]struct {
			result1 bool
			result2 error
		})
	}
	fake.isDatabaseFollowerReturnsOnCall[i] = struct {
		result1 bool
		result2 error
	}{result1, result2}
}

func (fake *FakeGatherer) IsDatabaseAvailable() bool {
	fake.isDatabaseAvailableMutex.Lock()
	ret, specificReturn := fake.isDatabaseAvailableReturnsOnCall[len(fake.isDatabaseAvailableArgsForCall)]
	fake.isDatabaseAvailableArgsForCall = append(fake.isDatabaseAvailableArgsForCall, struct{}{})
	fake.recordInvocation("IsDatabaseAvailable", []interface{}{})
	fake.isDatabaseAvailableMutex.Unlock()
	if fake.IsDatabaseAvailableStub != nil {
		return fake.IsDatabaseAvailableStub()
	}
	if specificReturn {
		return ret.result1
	}
	return fake.isDatabaseAvailableReturns.result1
}

func (fake *FakeGatherer) IsDatabaseAvailableCallCount() int {
	fake.isDatabaseAvailableMutex.RLock()
	defer fake.isDatabaseAvailableMutex.RUnlock()
	return len(fake.isDatabaseAvailableArgsForCall)
}

func (fake *FakeGatherer) IsDatabaseAvailableReturns(result1 bool) {
	fake.IsDatabaseAvailableStub = nil
	fake.isDatabaseAvailableReturns = struct {
		result1 bool
	}{result1}
}

func (fake *FakeGatherer) IsDatabaseAvailableReturnsOnCall(i int, result1 bool) {
	fake.IsDatabaseAvailableStub = nil
	if fake.isDatabaseAvailableReturnsOnCall == nil {
		fake.isDatabaseAvailableReturnsOnCall = make(map[int]struct {
			result1 bool
		})
	}
	fake.isDatabaseAvailableReturnsOnCall[i] = struct {
		result1 bool
	}{result1}
}

func (fake *FakeGatherer) DiskStats() (map[string]string, error) {
	fake.diskStatsMutex.Lock()
	ret, specificReturn := fake.diskStatsReturnsOnCall[len(fake.diskStatsArgsForCall)]
	fake.diskStatsArgsForCall = append(fake.diskStatsArgsForCall, struct{}{})
	fake.recordInvocation("DiskStats", []interface{}{})
	fake.diskStatsMutex.Unlock()
	if fake.DiskStatsStub != nil {
		return fake.DiskStatsStub()
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fake.diskStatsReturns.result1, fake.diskStatsReturns.result2
}

func (fake *FakeGatherer) DiskStatsCallCount() int {
	fake.diskStatsMutex.RLock()
	defer fake.diskStatsMutex.RUnlock()
	return len(fake.diskStatsArgsForCall)
}

func (fake *FakeGatherer) DiskStatsReturns(result1 map[string]string, result2 error) {
	fake.DiskStatsStub = nil
	fake.diskStatsReturns = struct {
		result1 map[string]string
		result2 error
	}{result1, result2}
}

func (fake *FakeGatherer) DiskStatsReturnsOnCall(i int, result1 map[string]string, result2 error) {
	fake.DiskStatsStub = nil
	if fake.diskStatsReturnsOnCall == nil {
		fake.diskStatsReturnsOnCall = make(map[int]struct {
			result1 map[string]string
			result2 error
		})
	}
	fake.diskStatsReturnsOnCall[i] = struct {
		result1 map[string]string
		result2 error
	}{result1, result2}
}

func (fake *FakeGatherer) BrokerStats() (map[string]string, error) {
	fake.brokerStatsMutex.Lock()
	ret, specificReturn := fake.brokerStatsReturnsOnCall[len(fake.brokerStatsArgsForCall)]
	fake.brokerStatsArgsForCall = append(fake.brokerStatsArgsForCall, struct{}{})
	fake.recordInvocation("BrokerStats", []interface{}{})
	fake.brokerStatsMutex.Unlock()
	if fake.BrokerStatsStub != nil {
		return fake.BrokerStatsStub()
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fake.brokerStatsReturns.result1, fake.brokerStatsReturns.result2
}

func (fake *FakeGatherer) BrokerStatsCallCount() int {
	fake.brokerStatsMutex.RLock()
	defer fake.brokerStatsMutex.RUnlock()
	return len(fake.brokerStatsArgsForCall)
}

func (fake *FakeGatherer) BrokerStatsReturns(result1 map[string]string, result2 error) {
	fake.BrokerStatsStub = nil
	fake.brokerStatsReturns = struct {
		result1 map[string]string
		result2 error
	}{result1, result2}
}

func (fake *FakeGatherer) BrokerStatsReturnsOnCall(i int, result1 map[string]string, result2 error) {
	fake.BrokerStatsStub = nil
	if fake.brokerStatsReturnsOnCall == nil {
		fake.brokerStatsReturnsOnCall = make(map[int]struct {
			result1 map[string]string
			result2 error
		})
	}
	fake.brokerStatsReturnsOnCall[i] = struct {
		result1 map[string]string
		result2 error
	}{result1, result2}
}

func (fake *FakeGatherer) CPUStats() (map[string]string, error) {
	fake.cPUStatsMutex.Lock()
	ret, specificReturn := fake.cPUStatsReturnsOnCall[len(fake.cPUStatsArgsForCall)]
	fake.cPUStatsArgsForCall = append(fake.cPUStatsArgsForCall, struct{}{})
	fake.recordInvocation("CPUStats", []interface{}{})
	fake.cPUStatsMutex.Unlock()
	if fake.CPUStatsStub != nil {
		return fake.CPUStatsStub()
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fake.cPUStatsReturns.result1, fake.cPUStatsReturns.result2
}

func (fake *FakeGatherer) CPUStatsCallCount() int {
	fake.cPUStatsMutex.RLock()
	defer fake.cPUStatsMutex.RUnlock()
	return len(fake.cPUStatsArgsForCall)
}

func (fake *FakeGatherer) CPUStatsReturns(result1 map[string]string, result2 error) {
	fake.CPUStatsStub = nil
	fake.cPUStatsReturns = struct {
		result1 map[string]string
		result2 error
	}{result1, result2}
}

func (fake *FakeGatherer) CPUStatsReturnsOnCall(i int, result1 map[string]string, result2 error) {
	fake.CPUStatsStub = nil
	if fake.cPUStatsReturnsOnCall == nil {
		fake.cPUStatsReturnsOnCall = make(map[int]struct {
			result1 map[string]string
			result2 error
		})
	}
	fake.cPUStatsReturnsOnCall[i] = struct {
		result1 map[string]string
		result2 error
	}{result1, result2}
}

func (fake *FakeGatherer) Invocations() map[string][][]interface{} {
	fake.invocationsMutex.RLock()
	defer fake.invocationsMutex.RUnlock()
	fake.databaseMetadataMutex.RLock()
	defer fake.databaseMetadataMutex.RUnlock()
	fake.followerMetadataMutex.RLock()
	defer fake.followerMetadataMutex.RUnlock()
	fake.isDatabaseFollowerMutex.RLock()
	defer fake.isDatabaseFollowerMutex.RUnlock()
	fake.isDatabaseAvailableMutex.RLock()
	defer fake.isDatabaseAvailableMutex.RUnlock()
	fake.diskStatsMutex.RLock()
	defer fake.diskStatsMutex.RUnlock()
	fake.brokerStatsMutex.RLock()
	defer fake.brokerStatsMutex.RUnlock()
	fake.cPUStatsMutex.RLock()
	defer fake.cPUStatsMutex.RUnlock()
	copiedInvocations := map[string][][]interface{}{}
	for key, value := range fake.invocations {
		copiedInvocations[key] = value
	}
	return copiedInvocations
}

func (fake *FakeGatherer) recordInvocation(key string, args []interface{}) {
	fake.invocationsMutex.Lock()
	defer fake.invocationsMutex.Unlock()
	if fake.invocations == nil {
		fake.invocations = map[string][][]interface{}{}
	}
	if fake.invocations[key] == nil {
		fake.invocations[key] = [][]interface{}{}
	}
	fake.invocations[key] = append(fake.invocations[key], args)
}

var _ metrics.Gatherer = new(FakeGatherer)
